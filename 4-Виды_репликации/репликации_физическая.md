# Физическая Репликация
## Создаем сетевую инфраструктуру и VM1:
```
yc vpc network create --name net-otus1 --description "net-otus1" && \
yc vpc subnet create --name subnet-otus1 --range 192.168.0.0/24 --network-name net-otus1 --description "subnet-otus1" && \
yc compute instance create --name 1 --hostname vm-otus1 --cores 2 --memory 4 --create-boot-disk size=15G,type=network-hdd,image-folder-id=standard-images,image-family=ubuntu-2404-lts --network-interface subnet-name=subnet-otus1,nat-ip-version=ipv4 --ssh-key ~/.ssh/id_rsa.pub 

yc compute instance create --name vm-otus2 --hostname vm-otus2 --cores 2 --memory 4 --create-boot-disk size=15G,type=network-hdd,image-folder-id=standard-images,image-family=ubuntu-2404-lts --network-interface subnet-name=subnet-otus1,nat-ip-version=ipv4 --ssh-key ~/.ssh/id_rsa.pub 
yc compute instance create --name vm-otus3 --hostname vm-otus3 --cores 2 --memory 4 --create-boot-disk size=15G,type=network-hdd,image-folder-id=standard-images,image-family=ubuntu-2404-lts --network-interface subnet-name=subnet-otus1,nat-ip-version=ipv4 --ssh-key ~/.ssh/id_rsa.pub
```

 список ВМ
```
yc compute instances list
```

Подключимся к VM:
```
IP_VM1=$(yc compute instance show --name vm-otus1 | grep -E ' +address' | tail -n 1 | awk '{print $2}') && ssh -o StrictHostKeyChecking=no yc-user@$IP_VM1
IP_VM2=$(yc compute instance show --name vm-otus2 | grep -E ' +address' | tail -n 1 | awk '{print $2}') && ssh -o StrictHostKeyChecking=no yc-user@$IP_VM2
IP_VM3=$(yc compute instance show --name vm-otus3 | grep -E ' +address' | tail -n 1 | awk '{print $2}') && ssh -o StrictHostKeyChecking=no yc-user@$IP_VM3
```
## На всех VM

Установим PostgreSQL на всех VM:
```
sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list' && wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - && sudo apt-get update && sudo apt -y install postgresql && sudo apt install unzip && sudo apt -y install mc
```
Проверка состояния
```
pg_lsclusters
systemctl status postgresql@18-main.service
```

## На VM1 (master)
### Подготовка конфигурации для репликации
Параметры /etc/postgresql/18/main/postgresql.conf
```
listen_addresses = '*'  
wal_level = replica  
wal_log_hints = on  
work_mem = 32MB
```
```
sudo cp /etc/postgresql/18/main/postgresql.conf  /etc/postgresql/18/main/postgresql.conf.$(date +%F).bak 

sudo sed -i "/^#listen_addresses/s/.*/listen_addresses = '*'/" /etc/postgresql/18/main/postgresql.conf
sudo sed -i "/^#wal_level/s/.*/wal_level = replica/" /etc/postgresql/18/main/postgresql.conf
sudo sed -i "/^#wal_log_hints/s/.*/wal_log_hints = on/" /etc/postgresql/18/main/postgresql.conf
sudo sed -i "/^#work_mem/s/.*/work_mem = 32MB/" /etc/postgresql/18/main/postgresql.conf
```

### Параметры /etc/postgresql/18/main/pg_hba.conf
```
host    all             all             192.168.0.0/24               scram-sha-256
host	  replication		имя_пользователя	0.0.0.0/0		scram-sha-256
```
```
sudo cp /etc/postgresql/18/main/pg_hba.conf  /etc/postgresql/18/main/pg_hba.conf.$(date +%F).bak 

echo "host    replication             postgres             192.168.0.0/24               scram-sha-256" | sudo tee -a /etc/postgresql/18/main/pg_hba.conf
```
Применение конфигурации 
```
sudo pg_ctlcluster 18 main restart
```
Устанавливаем пароль пользователю `postgres`
```
export PGPASSWORD=postgres
sudo -u postgres psql -c "alter user postgres password '${PGPASSWORD}';"
echo "localhost:5432:*:postgres:${PGPASSWORD}" > .pgpass
`chmod 0600 ~/.pgpass`
```
переход в постгрес
```
psql -h localhost -U postgres
```

```
create database otus;
\c otus

create table student as select generate_series(1,10000) as id, md5(random()::text)::char(10) as fio;

select * from student;

show wal_level;
```

## На VM2 (replica)
### Подготовка конфигурации для репликации
Остановка кластера конфигурации
```
sudo pg_ctlcluster 18 main stop
```

Параметры /etc/postgresql/18/main/postgresql.conf
```
listen_addresses = '*'  
wal_level = logical 
```
```
sudo cp /etc/postgresql/18/main/postgresql.conf  /etc/postgresql/18/main/postgresql.conf.$(date +%F).bak 

sudo sed -i "/^#listen_addresses/s/.*/listen_addresses = '*'/" /etc/postgresql/18/main/postgresql.conf
sudo sed -i "/^#wal_level/s/.*/wal_level = logical/" /etc/postgresql/18/main/postgresql.conf
```

### На VM2 удалим файлы

```
sudo pg_ctlcluster 18 main stop

sudo rm -rf /var/lib/postgresql/18/main
```
Параметры авторизации, аналогичные VM1
```
VM_OTUS1_IP=$(nslookup vm-otus1 |  grep Addres | tail -n +2 | awk '{print $2}')
echo "${VM_OTUS1_IP}:5432:*:postgres:postgres" >> .pgpass
chmod 0600 .pgpass
sudo cp .pgpass /var/lib/postgresql/
sudo chown postgres:postgres /var/lib/postgresql/.pgpass
```
Сделаем бэкап нашей БД. Ключ -R создаст заготовку управляющего файла recovery.conf.
```
sudo -u postgres pg_basebackup -D /var/lib/postgresql/18/main -R -X stream -C -S replica02 -v -h ${VM_OTUS1_IP} -w  
```

(Удалить слот репликации на vm-otus1
```
sudo -u postgres psql -c "SELECT slot_name, slot_type, active, active_pid, restart_lsn FROM pg_replication_slots;"
sudo -u postgres psql -c "SELECT * FROM pg_replication_slots;"
```
)

Файл хранит параметры аутентификации в открытом виде. Поэтому требуется использовать отдельного пользователя с правами только на репликацию
```
sudo cat /var/lib/postgresql/18/main/postgresql.auto.conf
```
удалим лог файл
```
sudo rm  /var/log/postgresql/postgresql-18-main.log
```
Стартуем кластер
```
sudo pg_ctlcluster 18 main start
```
Смотрим как стартовал
```
pg_lsclusters

sudo -u postgres psql
```
Проверим состояние репликации:
на мастере VM1
```sql
-- состояние репликации
SELECT * FROM pg_stat_replication \gx
-- wal file
SELECT * FROM pg_current_wal_lsn()\gx
-- слоты репликации
select * from pg_replication_slots \gx
```
на реплике VM2
```sql

select * from pg_stat_wal_receiver \gx

select pg_last_wal_receive_lsn() \gx
 
select pg_last_wal_replay_lsn() \gx
```
## Разрыв репликации
Перевод реплики в состояние мастера приводит к разрыву репликации и образованию двух master
```
sudo pg_ctlcluster 18 main promote
```
или
```
select pg_promote();
```
```
SELECT * FROM pg_stat_replication \gx
```

Восстановление после разрыва требует повторного копирования pg_basebackup всего кластера
Возможно использовать  `pg_rewind` https://postgrespro.ru/docs/postgresql/18/app-pgrewind

