1. Создать виртуальную машину с дефолтными параметрами - 1-2 ядра, 2-4Гб памяти, любой линукс
(на курсе Ubuntu) в YandexCloud / VirtualBox / Docker ...
2. Добавить свой ssh ключ
```
yc vpc network create --name net-otus1 --description "Net otus postgres adv 1" 
yc vpc subnet create --name subnet-otus1 --range 192.168.1.0/24 --network-name net-otus1 --description "SubNet otus postgres adv 1" 
yc compute instance create --name vm-otus1 --hostname vm-otus1 --cores 2 --memory 4 \
--create-boot-disk size=15G,type=network-hdd,image-folder-id=standard-images,image-family=ubuntu-2404-lts \
--network-interface subnet-name=subnet-otus1,nat-ip-version=ipv4 --ssh-key ~/.ssh/id_rsa.pub 
```
3. Зайти удаленным ssh (первая сессия)
```
ADDR_VM1=$(yc compute instance show --name vm-otus1 | grep -E ' +address' | tail -n 1 | awk '{print $2}')

ssh -o StrictHostKeyChecking=no yc-user@$ADDR_VM1
```
4. Поставить PostgreSQL из пакетов apt install
```
sudo apt update && sudo apt upgrade -y 
sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list' && wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - && sudo apt update && sudo apt install -y postgresql
```

5. Зайти вторым ssh (вторая сессия)
```
ADDR_VM1=$(yc compute instance show --name vm-otus1 | grep -E ' +address' | tail -n 1 | awk '{print $2}') 
ssh -o StrictHostKeyChecking=no yc-user@$ADDR_VM1
```

6. Запустить везде psql из под пользователя postgres

sess1 
```
~$ sudo -u postgres psql
```
sess2 
```
~$ sudo -u postgres psql
```
7. Выключить auto commit

sess1 
```
postgres=# \set AUTOCOMMIT 0
postgres=# \echo :AUTOCOMMIT
0
```

sess2 
```
postgres=# \set AUTOCOMMIT 0
postgres=# \echo :AUTOCOMMIT
0
```

8. Сделать в первой сессии новую таблицу и наполнить ее данными

sess1
```
postgres=# create database otus;
CREATE DATABASE
\c otus
otus=*# CREATE TABLE test2 (i serial, amount int);
CREATE TABLE

otus=*# INSERT INTO test2(amount) VALUES (100),(500);
otus=*# SELECT * FROM test2;
INSERT 0 2
 i | amount 
---+--------
 1 |    100
 2 |    500
(2 rows)

otus=*# COMMIT;
```
sess2
```
\c otus
otus=# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
(2 rows)
```

9. Посмотреть текущий уровень изоляции: `show transaction isolation`  
sess1
```
otus=# show transaction isolation level;
 transaction_isolation 
-----------------------
 read committed
(1 row)
```
sess2
```
otus=# show transaction isolation level;
 transaction_isolation 
-----------------------
 read committed
(1 row)
```

10. Начать новую транзакцию в обоих сессиях с дефолтным уровнем изоляции  
sess1
```
otus=# BEGIN TRANSACTION;
BEGIN
```

sess2
```
otus=# BEGIN TRANSACTION;
BEGIN
```

11. В первой сессии добавить новую запись  
sess1 
```
otus=*# INSERT INTO test2 (amount) VALUES (300);
INSERT 0 1
otus=*# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
 4 |    300
(3 rows)
```

12. Посмотреть таблицу во второй сессии. Видите ли вы новую запись и если да то почему?  
sess2
```
otus=*# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
(2 rows)
```
Запись с id 4 не видна, т.к включён режим `read committed` в котором не доступно Грязное чтение (Dirty read) - чтение данных не закомиченных с другой транзакции

13. Завершить первую транзакцию
sess1
```
otus=*# COMMIT;
COMMIT
```

14. Посмотреть таблицу во второй сессии. Видите ли вы новую запись и если да то почему? Завершить транзакцию во второй сессии.  
sess2
```
otus=*# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
 4 |    300
(3 rows)
```
Не смотря на то, что sess2 находится в транзакции, запись `id=4` видна, тк. в режиме `read committed` доступно Фантомное чтение (Phantom read) - доступность в транзакции новых строк созданных в других транзакциях

```
otus=*# COMMIT;
COMMIT
```
15. Начать новые транзакции с repeatable read  
sess1
```
otus=*# BEGIN TRANSACTION;
BEGIN
otus=# SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET
otus=*# show transaction isolation level;
 transaction_isolation 
-----------------------
 repeatable read
(1 row)
```
sess2 - аналогично

16. В первой сессии добавить новую запись  
sess1
```
otus=*# INSERT INTO test2 (amount) VALUES (500);
INSERT 0 1
otus=*# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
 4 |    300
 5 |    500
(4 rows)
```

17. Посмотреть таблицу во второй сессии. Видите ли вы новую запись и если да то почему?  
sess2
```
otus=*# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
 4 |    300
(3 rows)
```
Не закоммиченная запись `id=5` не доступна в транзакции в sess2, аналогично как и в п.12 т.к не доступно Грязное чтение (Dirty read)  

18. Завершить первую транзакцию  
sess1
```
otus=*# COMMIT;
COMMIT
```

19. Посмотреть таблицу во второй сессии. Видите ли вы новую запись и если да то почему? Завершить транзакцию во второй сессии.  
sess2
```
otus=*# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
 4 |    300
(3 rows)
```
В sess2 включён режим repeatable read при котором в Postgres исключено Фантомное чтение (Phantom read), т.е транзакция не видит даже закоммиченные строки добавленные после её начала.

sess2
```
otus=*# COMMIT;
COMMIT
otus=# SELECT * FROM test2;
 i | amount 
---+--------
 1 |    100
 2 |    500
 4 |    300
 5 |    500
(4 rows)
```

------------------------------  
Проверка  Неповторяемое чтение (Non-repeatable read) в режиме `repeatable read`  
sess1
```
otus=# begin transaction;
BEGIN
otus=*# select * from test2;
 i | amount 
---+--------
 1 |    100
(1 row)
```

sess2 
```
otus=# begin transaction;
BEGIN
otus=*# SET TRANSACTION ISOLATION LEVEL repeatable read;
SET
otus=*# select * from test2;
 i | amount 
---+--------
 1 |    100
(1 row)
```
Изменяем строку в транзакции sess1
sess1  
```
otus=*# UPDATE test2 SET amount = 101 WHERE i=1;
UPDATE 1
otus=*# COMMIT;
COMMIT
otus=# select * from test2;
 i | amount 
---+--------
 1 |    101
(1 row)

```

sess2
```
otus=*# select * from test2;
 i | amount 
---+--------
 1 |    100
(1 row)
```
В режиме `repeatable read` в пределах транзакции строка не изменяется.

sess2
```
otus=*# UPDATE test2 SET amount = 101 WHERE i=1;
ERROR:  could not serialize access due to concurrent update
otus=!# commit;
ROLLBACK
```
Но, попытка в sess2 изменить строку изменённую в транзакции sess1 приводит к конфликту



Остановка и удаление VM в ЯО
```
yc compute instance delete vm-otus1 &&\
yc vpc subnet delete subnet-otus1 &&\
yc vpc network delete net-otus1
```