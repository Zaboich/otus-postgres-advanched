/*
Слот репликации в PostgreSQL — это механизм, который позволяет управлять потоками данных между мастером
 и репликами, обеспечивая надежность и согласованность данных при репликации. 

Слот репликации — это структура данных, которая хранит информацию о состоянии репликации 
для конкретного клиента (реплики). Он отслеживает, какие WAL-файлы были отправлены и приняты клиентом,
 чтобы гарантировать, что все необходимые данные будут доступны для реплики.

▎Как работает слот репликации?

1. Создание слота:
   Слот создается на мастере с помощью команды:

   SELECT * FROM pg_create_physical_replication_slot('my_slot');

2. Отправка данных:
   Когда реплика подключается к мастеру, она использует слот для получения WAL-файлов. 
   Мастер будет хранить WAL-файлы, пока они не будут подтверждены репликой. 
   Это предотвращает удаление WAL-файлов, которые еще могут понадобиться для восстановления данных
   на реплике.

3. Подтверждение:
   После того как реплика успешно применяет полученные WAL-файлы, она отправляет подтверждение мастеру, 
   и слот обновляется.

4. Управление пространством:
   Если реплика временно отключена или не может применить данные (например, из-за проблем с сетью), 
   WAL-файлы будут накапливаться на мастере. Это может привести к потреблению большого объема 
   дискового пространства. Поэтому важно следить за состоянием слотов и очищать их при необходимости.

▎Для чего нужен слот репликации?

1. Управление репликацией:
   Слоты позволяют более эффективно управлять репликацией, так как они гарантируют, 
   что все необходимые WAL-файлы будут доступны для реплик.

2. Согласованность данных:
   Слоты помогают поддерживать согласованность данных между мастером и репликами, обеспечивая, 
   что реплики не потеряют данные, даже если они временно отключены.

3. Поддержка логической репликации:
   В PostgreSQL также существуют логические слоты, которые позволяют реализовывать более сложные сценарии 
   репликации, включая выборочную репликацию определенных таблиц или данных.
*/


# Virtual Machines (Compute Cloud) https://cloud.yandex.ru/docs/free-trial/

Создание виртуальной машины:
https://cloud.yandex.ru/docs/compute/quickstart/quick-create-linux



# Создаем сетевую инфраструктуру и VM1:
yc vpc network create --name otus-net --description "otus-net" && \
yc vpc subnet create --name otus-subnet --range 192.168.0.0/24 --network-name otus-net --description "otus-subnet" && \
yc compute instance create --name otus-vm1 --hostname otus-vm1 --cores 2 --memory 4 --create-boot-disk size=15G,type=network-hdd,image-folder-id=standard-images,image-family=ubuntu-2404-lts --network-interface subnet-name=otus-subnet,nat-ip-version=ipv4 --ssh-key ~/yc_key.pub 

# Создаем VM2:
yc compute instance create --name otus-vm2 --hostname otus-vm2 --cores 2 --memory 4 --create-boot-disk size=15G,type=network-hdd,image-folder-id=standard-images,image-family=ubuntu-2404-lts --network-interface subnet-name=otus-subnet,nat-ip-version=ipv4 --ssh-key ~/yc_key.pub 

# Создаем VM3:
yc compute instance create --name otus-vm3 --hostname otus-vm3 --cores 2 --memory 4 --create-boot-disk size=15G,type=network-hdd,image-folder-id=standard-images,image-family=ubuntu-2404-lts --network-interface subnet-name=otus-subnet,nat-ip-version=ipv4 --ssh-key ~/yc_key.pub 

# Подключимся к VM:
vm_ip_address=$(yc compute instance show --name otus-vm1 | grep -E ' +address' | tail -n 1 | awk '{print $2}') && ssh -o StrictHostKeyChecking=no -i ~/yc_key yc-user@$vm_ip_address

vm_ip_address=$(yc compute instance show --name otus-vm2 | grep -E ' +address' | tail -n 1 | awk '{print $2}') && ssh -o StrictHostKeyChecking=no -i ~/yc_key yc-user@$vm_ip_address

vm_ip_address=$(yc compute instance show --name otus-vm3 | grep -E ' +address' | tail -n 1 | awk '{print $2}') && ssh -o StrictHostKeyChecking=no -i ~/yc_key yc-user@$vm_ip_address

# Установим PostgreSQL на всех VM:
sudo apt update && sudo apt upgrade -y -q && sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list' && wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - && sudo apt-get update && sudo apt -y install postgresql && sudo apt install unzip && sudo apt -y install mc

# список ВМ
yc compute instances list

pg_lsclusters
systemctl status postgresql

sudo nano /etc/postgresql/18/main/postgresql.conf
#listen_addresses = 'localhost'
listen_addresses = '*'
wal_level = replica | logical
wal_log_hints = on

sudo nano /etc/postgresql/18/main/pg_hba.conf
host    all             all             0.0.0.0/0               scram-sha-256
host	  replication		имя_пользователя	0.0.0.0/0		scram-sha-256

sudo pg_ctlcluster 18 main restart

переход в постгрес
sudo -u postgres psql

зададим пароль
\password

create database otus;
\c otus

create table student as 
select 
  generate_series(1,10) as id,
  md5(random()::text)::char(10) as fio;


select * from student;

show wal_level;


# На 2 VM удалим файлы
sudo rm -rf /var/lib/postgresql/18/main

Сделаем бэкап нашей БД. Ключ -R создаст заготовку управляющего файла recovery.conf.
pg_basebackup --help

sudo -u postgres pg_basebackup -D /var/lib/postgresql/18/main -R -X stream -C -S replica01 -v -h 84.201.133.176 -W

посмотрим
cat /var/lib/postgresql/18/main/postgresql.auto.conf

удалим лог файл
/var/log/postgresql/

Стартуем кластер
sudo pg_ctlcluster 18 main start

Смотрим как стартовал
pg_lsclusters


sudo -u postgres psql -d otus

Проверим состояние репликации:
на мастере
SELECT * FROM pg_stat_replication \gx
SELECT * FROM pg_current_wal_lsn();
select * from pg_replication_slots;

на реплике
select * from pg_stat_wal_receiver \gx
select pg_last_wal_receive_lsn();
select pg_last_wal_replay_lsn();

Перевод в состояние мастера
sudo pg_ctlcluster 18 main promote
или
select pg_promote();

SELECT * FROM pg_stat_replication \gx



дока по pg_rewind https://postgrespro.ru/docs/postgresql/18/app-pgrewind


--------Логическая репликация
# 2VM
show wal_level;
--ALTER SYSTEM SET wal_level = logical;

создать пользователя
create user repl1 replication password '2222';

выдать права на таблицу student
GRANT select ON TABLE student TO repl1;

создаем публикацию:
CREATE PUBLICATION test_pub FOR TABLE student;

Просмотр созданной публикации
\dRp+



# 3VM
sudo -u postgres psql
create database otus;
\c otus
create table student(id integer, fio char(10));


создадим подписку 
--создадим подписку к БД по Порту с Юзером и Паролем и Копированием данных=true
CREATE SUBSCRIPTION otus_sub 
CONNECTION 'host=178.154.229.124 port=5432 user=repl1 password=2222 dbname=otus' 
PUBLICATION test_pub WITH (copy_data = true);

\dRs
SELECT * FROM pg_stat_subscription \gx


--добавим одинаковые данные
---добавить индекс
create unique index on student(id);
\dS+ student

добавить одиноковые значения
удалить на втором экземпляре конфликтные записи

SELECT * FROM pg_stat_subscription \gx	просмотр состояния (при конфликте пусто)

просмотр логов
$ tail -n 10 /var/log/postgresql/postgresql-18-main.log

drop subscription otus_sub;
drop publication test_pub;


------------- !!! подписка на одну и ту же таблицу

create table oscar(id int, year int, age int, name varchar(20), movie varchar(50));

у обоих серверов 
ALTER SYSTEM SET wal_level = logical;

Рестартуем кластера
sudo pg_ctlcluster 16 main restart
sudo pg_ctlcluster 16 main2 restart

sudo -u postgres psql -p 5434 -d otus
sudo -u postgres psql -p 5435 -d otus

Задать пароль
\password 
pas16-1
pas16-2

На первом сервере создаем публикацию:
CREATE PUBLICATION pub_1 FOR TABLE oscar;


На втором сервере создаем публикацию:
CREATE PUBLICATION pub_2 FOR TABLE oscar;

Просмотр созданной публикации
\dRp+

создадим подписку на втором экземпляре
CREATE SUBSCRIPTION sub_1 
CONNECTION 'host=localhost port=5434 user=postgres password=pas16-1 dbname=otus' 
PUBLICATION pub_1 WITH (copy_data = false, origin=none);

создадим подписку на первом экземпляре
CREATE SUBSCRIPTION sub_2 
CONNECTION 'host=localhost port=5435 user=postgres password=pas16-2 dbname=otus' 
PUBLICATION pub_2 WITH (copy_data = false, origin=none);

\dRs

insert into oscar(id, year, age, name, movie) values(100, 2024, 30, 'NoName', 'Film1');

drop subscription sub_1;
drop subscription sub_2;
drop publication pub_1;
drop publication pub_2;




-------- создание побликации на все таблицы
create publication test_pub for all tables;

create table students12 as select generate_series(1, 10) as id, md5(random()::text)::char(10) as fio; 
create table if not exists students12 (id int, fio char(10));

create subscription test_sub
connection 'host=localhost port=5432 user=postgres password=postgres dbname=otus'
publication test_pub with (copy_data = true);



---------- Удаление подписки на реплике при отсутствующем слоте
ALTER SUBSCRIPTION testt_sub DISABLE;
ALTER SUBSCRIPTION testt_sub SET (slot_name=NONE);
DROP SUBSCRIPTION testt_sub;


# удаление VM
yc compute instance delete otus-vm3

yc compute instance delete otus-vm2

yc compute instance delete otus-vm1 && yc vpc subnet delete otus-subnet && yc vpc network delete otus-net
